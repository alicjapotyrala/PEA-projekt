int * TabuSearch::najlepszeSasiedztwo(int *trasa, double **macierz, int miasta, TabuList *tlist, float asp){
	double obecna_droga, najlepsza_droga;
	float improvment;
	//double permutacja1 = new double[miasta];
	int *najlepsza = new int[miasta];

	for (int i = 0; i < miasta; i++){
		najlepsza[i] = trasa[i];
	}

	for (int i = 0; i < miasta- 1; i++)
	{
		for (int j = i + 1; j < miasta; j++)
		{
			tlist->decrement_tabu(miasta);
			int temp = trasa[i];
			trasa[i] = trasa[j];
			trasa[j] = temp;

			obecna_droga = droga(macierz,miasta,trasa);
			najlepsza_droga = droga(macierz,miasta,najlepsza);

			if (tlist->nrKadencji(i,j) != 0) {
				if (obecna_droga < najlepsza_droga) {
					improvment = (float)(najlepsza_droga - obecna_droga) / najlepsza_droga;
					if (improvment >= asp) {
						tlist->reset(miasta);
						delete[] najlepsza;
						najlepsza = new int[miasta];
						for (int i = 0; i < miasta; i++){
							najlepsza[i] = trasa[i];
						}
						tlist->ruch_tabu(i, j, miasta);
					}
				}
				int temp1 = trasa[i];
				trasa[i] = trasa[j];
				trasa[j] = temp1;
				break;
			}
			else if (obecna_droga < najlepsza_droga) {
				delete[] najlepsza;
				najlepsza = new int[miasta];
				for (int i = 0; i < miasta; i++){
					najlepsza[i] = trasa[i];
				}
				tlist->ruch_tabu(i, j, miasta);
			}
			int temp2 = trasa[i];
			trasa[i] = trasa[j];
			trasa[j] = temp2;
		}
	}
	return najlepsza;

	
}

double TabuSearch::ts(int max_cadence, double ** macierz1, int miasta, int MAX_TRIES, int & rozwiazanie)
{
	start();
	TabuList *tlist = new TabuList(miasta, max_cadence);
	int max_tries = MAX_TRIES; // do parametru
	int *best_route = new int[miasta];
	int *permutacja1 = new int[miasta];
	permutacja(permutacja1, miasta);

	for (int i = 0; i < miasta; i++){
		best_route[i] = permutacja1[i];
	}

	int *current_route = new int[miasta];
	for (int i = 0; i < miasta; i++){
		current_route[i] = best_route[i];
	}


	for (int i = 0; i < max_tries; i++)
	{
		current_route = najlepszeSasiedztwo(current_route, macierz1, miasta, tlist, 0.5);
		if (droga(macierz1, miasta, current_route) < droga(macierz1,miasta,best_route)) {
			delete best_route;
			best_route = new int[miasta];
			for (int j = 0; j < miasta; j++){
				best_route[j] = current_route[j];
			}
		}

	}

	rozwiazanie = droga(macierz1, miasta, best_route);

	return stop();
}